---
layout: post
title: "高性能javascript笔记：第3章 DOM编程"
description: ""
category: js
tags: [Javascript]
---
{% include JB/setup %}

##第3章 DOM编程

###3.1 浏览器中的DOM
文档对象模型（DOM）是一个与语言无关的，用于操作XML和HTML文档的应用程序接口（API）。
浏览器通常会把DOM和Javascript独立实现，而两个相互独立的功能只要通过接口彼此连接，就会产生消耗。

##3.2 DOM访问与修改
访问DOM的次数越多，代码的运行速度越慢。因此，我们要减少访问DOM的次数，把运算尽量留在ECMAScript这端处理。
**节点克隆**
使用DOM方法更新页面内容的另一个途径是克隆已有元素，而不是创建新元素——即使用element.cloneNode()(element表示已有节点)替代document.createElement()。

**HTML集合**
HTML集合一直与文档保持着连接，每次你需要最新的信息时，都会重复执行查询的过程，哪怕只是获取集合里的元素个数（即访问集合里的length属性）也是如此。
在循环的条件控制语句中读取数组的length属性是不推荐的做法，读取一个集合的length比读取普通数组的lenght要慢很多，因为每次都要重新查询。

很多情况下如果只需要遍历一个相对较小的集合，那么缓存length就够了。但由于遍历数组比遍历集合快，因此如果现将集合元素拷贝到数组中，那么访问它的属性会更快。请记住，这回因额外的步骤带来消耗，而且会多遍历一次数组，因此应当评估在特定条件下，使用数组拷贝是否有帮助。

**访问集合元素时使用局部变量**
当同一个DOM属性或方法需要多次访问时，最好使用一个局部变量缓存此成员。当遍历一个集合时，首要优化原则是把集合存储在局部变量中，并把length缓存在循环外部，然后，使用局部变量访问这些需要多次访问的元素。

**遍历DOM**
最新的浏览器提供一个名为querySelectorAll()的原生DOM方法，这比使用Javascript和DOM来遍历查找元素要快得多。（支持浏览器：IE8+,Firefox3.5+,Safari3.1+,Chrome1+以及Opera10）

如果你使用Javascript库提供的选择器API，应确保该库在底层实现中使用原生API。

另外，也可以使用querySelector()来获取第一个匹配的节点。

###3.3 重绘与重排
当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，同时其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树，这个过程称为“重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为“重绘（repaint）”。

**重排何时发生？**

*	添加或删除可见的DOM元素
*	元素位置改变
*	元素尺寸改变（如外边距，内边距，边框厚度，宽度，高度等变化）
*	内容改变（如文本改变或图片被另一个不同尺寸的图片替代）
*	页面渲染器初始化
*	浏览器窗口尺寸改变

**渲染树变化的排队与刷新**
由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。然后，你可能会强制刷新队列并要求计划任务立刻执行。获取布局信息的操作会导致队列刷新。
以下属性和方法需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排以返回正确的值：

*	offsetTop,offsetLeft,offsetWidth,offsetHeight
*	scrollTop,scrollLeft,scrollWidth,scrollHeigth
*	clientTop,clientLeft,clientWidth,clientHeight
*	getComputedStyle()(currentStyle in IE)

因此，高效的方法是不要在布局信息改变时查询它，即等读取computed样式的代码放在一起，移到后面。

**最小化重排和重绘**
为了减少重排重绘的发生次数，应该合并多次对DOM和样式的修改，然后一次处理掉。
如下例：

	var el=document.getElementById('mydiv');
	el.style.borderLeft='1px';
	el.style.borderRight='2px';
	el.style.padding='5px';

示例中有三个样式属性被改变，每一个都会影响元素的几何结构。最坏的情况下，会导致浏览器触发三次重排。大部分现代浏览器为此做了优化，只会触发一次重排，但在旧版浏览器或有一个分离的异步处理过程时（比如使用计时器），仍然效率低下。

一个能够达到同样效果且更高效的方式是：合并所有的改变然后一次处理，这样只会修改DOM一次。使用cssText属性可以实现：

	var el=document.getElementById('mydiv');
	el.style.cssText='border-left:1px;border-right:2px;padding:5px';
	
另一个一次性修改样式的办法是修改CSS的class名称，而不是修改内联样式。这种方法适用于那些不依赖于运行逻辑和计算的情况。改变CSS的class名称的方法更清晰，更易于维护；它有助于保持你的脚本与免除显示性代码，尽管它可能带来轻微的性能影响，因为改变类时需要检查级联样式。

	var el=document.getElementById('mydiv');
	el.className='active';
	
批量修改DOM
当你需要对DOM元素进行一系列操作时，可以通过以下步骤减少重绘和重排次数:

1. 使元素脱离文档流。
2. 对其应用多重改变。
3. 把元素带回文档中。

用这种方法，就只会在第一步和第三步触发重排。如果忽略这两个步骤的话，在第二步所产生的任何修改都会触发一次重排。

有三种基本方法可以使DOM脱离文档：

*	隐藏元素，应用修改，重新显示。	
*	使用文档片段（document fragment）在当前DOM之外构建一个子树，再把它拷贝回文档。
*	将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素。
	
推荐尽可能使用第二方案，因为它所产生的DOM遍历和重排次数最少。

**缓存布局信息**
尽量减少布局信息（如offsets，scroll values等）的获取次数，获取后把它赋值给局部变量，然后再操作局部变量。

**让元素脱离动画流**
1. 使用绝对位置定位页面上的动画元素，将其脱离文档流。
2. 让元素动起来。当它扩大时，会临时覆盖部分页面。但这只是页面一个小区域的重绘过程，不会产生重排并重绘页面的大部分内容。
3. 当动画结束时恢复定位，从而只会下移一次文档的其他元素。

**IE和hover**
从IE7开始，IE允许在任何元素上使用`:hover`这个CSS伪选择器。然而，如果你有大量元素使用了`:hover`，那么会降低响应速度。此问题在IE8中更为明显。

###3.4 事件委托
每绑定一个事件处理器都是有代价的，它要么是加重了页面负担，要么是增加了运行期的执行时间。需要访问和修改的DOM元素越多，应用程序越慢，特别是事件绑定通常发生在onload时。

事件委托是基于这样一个事实：事件逐层冒泡并能被父级元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。





1. 最小化DOM访问次数，尽可能在Javascript端处理。
2. 如果需要多次访问某个DOM节点，请使用局部变量存储它的引用。
3. 小心处理HTML集合，因为它实时连系着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷贝到一个数组中。
4. 如果可能的话，使用速度更快的API，比如querySelectorAll()和firstElementChild。
5. 要留意重绘和重排；批量修改样式时，“离线”操作DOM树，使用缓存，并减少访问布局信息的次数。
6. 动画中使用绝对定位，使用拖放代理。
7. 使用事件委托来减少事件处理器的数量。






